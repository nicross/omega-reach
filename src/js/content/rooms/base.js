content.rooms.base = {
  // Attributes
  id: undefined,
  name: undefined,
  description: undefined,
  interactLabel: 'Examine',
  moveDownLabel: 'No south',
  moveLeftLabel: 'No west',
  moveRightLabel: 'No east',
  moveUpLabel: 'No north',
  // Transitions
  transitions: {},
  // State
  defaultState: {},
  state: {},
  // Main methods
  export: function () {
    return {...this.defaultState, ...this.state}
  },
  extend: function (definition) {
    return engine.fn.extend(this, definition)
  },
  import: function (state) {
    this.state = {...this.defaultState, ...state}
    return this
  },
  reset: function () {
    this.state = {...this.defaultState}
    return this
  },
  // Attribute getters (override to return dynamic values)
  getAttributeLabels: function () {
    return []
  },
  getDescription: function () {
    return this.description
  },
  getInteractLabel: function () {
    return this.interactLabel
  },
  getMoveDownLabel: function () {
    return this.moveDownLabel
  },
  getMoveLeftLabel: function () {
    return this.moveLeftLabel
  },
  getMoveRightLabel: function () {
    return this.moveRightLabel
  },
  getMoveUpLabel: function () {
    return this.moveUpLabel
  },
  getName: function () {
    return this.name
  },
  isDiscovered: () => true,
  // Interaction
  canInteract: () => false,
  interact: function () {
    if (!this.canInteract()) {
      return this
    }

    const result = this.onInteract()

    content.location.emit('interact', {
      result,
      room: this,
    })

    this.generateSolution()

    return result
  },
  onInteract: () => {}, // Return a string to announce to interface
  // Solution
  solution: undefined,
  generateSolution: function (preference = app.settings.computed.inputPreference) {
    if (!this.canInteract()) {
      return
    }

    if (preference == 'keyboard') {
      this.solution = engine.fn.choose([...Object.values(
        app.controls.interactions.keyboardMappings()
      )], Math.random())
    } else if (preference == 'mouse') {
      this.solution = engine.tool.vector3d.create({
        x: engine.fn.randomFloat(0, 1),
        y: engine.fn.randomFloat(-1, 1),
        z: engine.fn.randomFloat(-1, 1),
      }).normalize()
    } else {
      this.solution = engine.tool.vector3d.create({
        x: engine.fn.randomFloat(-1, 1),
        y: engine.fn.randomFloat(-1, 1),
        z: engine.fn.randomFloat(-1, 1),
      }).normalize()
    }

    return this.solution
  },
  // Movement
  canEnter: () => true,
  canMove: function (direction) {
    // TODO: Handle scrollable rooms

    return content.rooms.get(this.transitions[direction])?.canEnter()
      ?? false
  },
  canMoveDown: function () {
    return this.canMove('down')
  },
  canMoveLeft: function () {
    return this.canMove('left')
  },
  canMoveRight: function () {
    return this.canMove('right')
  },
  canMoveUp: function () {
    return this.canMove('up')
  },
  enter: function () {
    this.generateSolution()
    this.onEnter()

    return this
  },
  exit: function () {
    this.onExit()

    return this
  },
  move: function (direction) {
    if (!this.canMove(direction)) {
      return this
    }

    content.location.set(this.transitions[direction])

    return this
  },
  moveDown: function () {
    return this.move('down')
  },
  moveLeft: function () {
    return this.move('left')
  },
  moveRight: function () {
    return this.move('right')
  },
  moveUp: function () {
    return this.move('up')
  },
  onEnter: function () {},
  onExit: function () {},
}
